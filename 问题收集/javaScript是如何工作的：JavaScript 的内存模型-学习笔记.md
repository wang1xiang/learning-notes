#### 引擎、运行时和调用堆栈的概述

- JavaScript 引擎的流行示例是谷歌的 V8 引擎，V8 引擎由两个部件组成：
  > - memory Heap(内存堆) - 内存分配的地方
  > - Call Stack(调用堆栈) - 代码执行的地方
- RunTime(运行时)
  > 有些浏览器的 API 经常被人们使用(比如 SetTimeout)，但是这些并不是引擎提供的，这些引擎之外的 API，我们称之为 Web API，比如 DOM、AJAX、setTimout 等等
  > 还包含事件循环和回调队列
- 调用栈
  > JavaScript 是单线程变成语言，因此只有一个调用堆栈，因此一次只能做一件事。调用栈是一种数据结构，记录了我们在程序中的位置，如果运行一个函数，他就会将其放到栈顶，当函数返回时，就会将此函数从栈中弹出
  ```js
  function bar() {
    console.log('s')
  }
  function foo() {
    bar()
  }
  foo()
  ```
  > 如上，当程序开始执行时，调用栈是空的，第一步调用 foo 函数，foo 函数进栈，foo 调用 bar，bar 函数进入栈，接着 bar 函数打印输出，出栈，bar 返回，foo 函数出栈(每一个进入栈的都被称为调用帧)
  > "堆栈溢出"当调用帧的数量达到调用栈的最大时就会发生，比如递归
  ```js
  function foo() {
    foo()
  }
  foo()
  ```
  > 每次调用都会添加相同的函数到调用堆栈中，最终会发生"堆栈溢出"(VM107:1 Uncaught RangeError: Maximum call stack size exceeded)
  > 所以，单线程运行代码有好有坏，好处是不用处理多线程中的复杂场景--如死锁，坏处是只有一个调用堆栈，当某段代码运行较慢时，会发生什么？继续...
- 并发和事件循环
  > 假如你希望在浏览器中使用 JavaScript 进行一些复杂的图像转换，这时候调用堆栈有函数要执行，浏览器不能做其他事情--堵塞，这意味着浏览器不能运行其他代码，它被卡住了，如果想在应用中使用流畅的页面效果，这就会产生问题。
  > 一旦浏览器开始处理调用队中的众多任务，可能会停止响应相当长一段时间，大多数浏览器会报一个错误，询问是否终止页面。
  > 那么，我们怎样才能在不阻塞 UI 和不使浏览器失去响应的情况下执行大量代码呢?解决方案是异步回调。

#### 深入 V8 引擎&编写优化代码的 5 个技巧

- JavaScript 引擎是执行 JavaScript 代码的程序或解释器。
- 为什么创建 V8 引擎？
  > V8 引擎由谷歌构建，使用 C++编写，与其他引擎不同的是 V8 也同样适用于流行的 nodeJs 中。最初设计是为了提高 web 浏览器中 JavaScript 执行的性能。为了获得速度，V8可以将JavaScript代码转换为可更高效的机器码，而不是编译器。它通过实现JIT(just-in-time)编译器将JavaScript代码编译成可执行的机器码，就像其他引擎所做的一样，不同的是V8引擎不会生成字节码或任何中间代码。
- V8曾有两个编译器
  > - full-codegen 一个简单和非常快的编译器，产生简单和相对较慢的机器码。
  > - CrankShaft 一种更复杂的(just-in-time)的优化编译器，生成高度优化的代码。
  > V8引擎在内部使用多个线程，主线程获取代码、编译代码并执行；还有一个单独的线程用于编译，因此主线程可以在优化代码的时候继续执行；还有一个Profiler线程，它会告诉运行时花了多少时间，让CrankShaft优化它们；一些线程处理垃圾收集器
  > 当JavaScript代码第一次执行时，full-codegen编译器将代码翻译为机器码，不进行任何转换，这使得它可以快速的执行机器代码。当代码运行一段时间后，Profiler进程分析出哪些方法可以进行优化，CrankShaft从另一个线程开始优化，大多数优化都是在这一进程中完成。
- 内联代码
  > 第一个优化就是内尽可能多的代码，内联代码指将调用函数的代码行转换为函数主体的过程。